// Code generated by test DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package example

import (
	"context"
	"reflect"

	"github.com/khulnasoft/khulnasoft/sdk/v3/go/khulnasoft"
	"replace-on-change/example/internal"
)

type Dog struct {
	khulnasoft.CustomResourceState

	Bone khulnasoft.StringPtrOutput `khulnasoft:"bone"`
}

// NewDog registers a new resource with the given unique name, arguments, and options.
func NewDog(ctx *khulnasoft.Context,
	name string, args *DogArgs, opts ...khulnasoft.ResourceOption) (*Dog, error) {
	if args == nil {
		args = &DogArgs{}
	}

	replaceOnChanges := khulnasoft.ReplaceOnChanges([]string{
		"bone",
	})
	opts = append(opts, replaceOnChanges)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Dog
	err := ctx.RegisterResource("example::Dog", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDog gets an existing Dog resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDog(ctx *khulnasoft.Context,
	name string, id khulnasoft.IDInput, state *DogState, opts ...khulnasoft.ResourceOption) (*Dog, error) {
	var resource Dog
	err := ctx.ReadResource("example::Dog", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Dog resources.
type dogState struct {
}

type DogState struct {
}

func (DogState) ElementType() reflect.Type {
	return reflect.TypeOf((*dogState)(nil)).Elem()
}

type dogArgs struct {
}

// The set of arguments for constructing a Dog resource.
type DogArgs struct {
}

func (DogArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dogArgs)(nil)).Elem()
}

type DogInput interface {
	khulnasoft.Input

	ToDogOutput() DogOutput
	ToDogOutputWithContext(ctx context.Context) DogOutput
}

func (*Dog) ElementType() reflect.Type {
	return reflect.TypeOf((**Dog)(nil)).Elem()
}

func (i *Dog) ToDogOutput() DogOutput {
	return i.ToDogOutputWithContext(context.Background())
}

func (i *Dog) ToDogOutputWithContext(ctx context.Context) DogOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(DogOutput)
}

// DogArrayInput is an input type that accepts DogArray and DogArrayOutput values.
// You can construct a concrete instance of `DogArrayInput` via:
//
//	DogArray{ DogArgs{...} }
type DogArrayInput interface {
	khulnasoft.Input

	ToDogArrayOutput() DogArrayOutput
	ToDogArrayOutputWithContext(context.Context) DogArrayOutput
}

type DogArray []DogInput

func (DogArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Dog)(nil)).Elem()
}

func (i DogArray) ToDogArrayOutput() DogArrayOutput {
	return i.ToDogArrayOutputWithContext(context.Background())
}

func (i DogArray) ToDogArrayOutputWithContext(ctx context.Context) DogArrayOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(DogArrayOutput)
}

// DogMapInput is an input type that accepts DogMap and DogMapOutput values.
// You can construct a concrete instance of `DogMapInput` via:
//
//	DogMap{ "key": DogArgs{...} }
type DogMapInput interface {
	khulnasoft.Input

	ToDogMapOutput() DogMapOutput
	ToDogMapOutputWithContext(context.Context) DogMapOutput
}

type DogMap map[string]DogInput

func (DogMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Dog)(nil)).Elem()
}

func (i DogMap) ToDogMapOutput() DogMapOutput {
	return i.ToDogMapOutputWithContext(context.Background())
}

func (i DogMap) ToDogMapOutputWithContext(ctx context.Context) DogMapOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(DogMapOutput)
}

type DogOutput struct{ *khulnasoft.OutputState }

func (DogOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Dog)(nil)).Elem()
}

func (o DogOutput) ToDogOutput() DogOutput {
	return o
}

func (o DogOutput) ToDogOutputWithContext(ctx context.Context) DogOutput {
	return o
}

func (o DogOutput) Bone() khulnasoft.StringPtrOutput {
	return o.ApplyT(func(v *Dog) khulnasoft.StringPtrOutput { return v.Bone }).(khulnasoft.StringPtrOutput)
}

type DogArrayOutput struct{ *khulnasoft.OutputState }

func (DogArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Dog)(nil)).Elem()
}

func (o DogArrayOutput) ToDogArrayOutput() DogArrayOutput {
	return o
}

func (o DogArrayOutput) ToDogArrayOutputWithContext(ctx context.Context) DogArrayOutput {
	return o
}

func (o DogArrayOutput) Index(i khulnasoft.IntInput) DogOutput {
	return khulnasoft.All(o, i).ApplyT(func(vs []interface{}) *Dog {
		return vs[0].([]*Dog)[vs[1].(int)]
	}).(DogOutput)
}

type DogMapOutput struct{ *khulnasoft.OutputState }

func (DogMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Dog)(nil)).Elem()
}

func (o DogMapOutput) ToDogMapOutput() DogMapOutput {
	return o
}

func (o DogMapOutput) ToDogMapOutputWithContext(ctx context.Context) DogMapOutput {
	return o
}

func (o DogMapOutput) MapIndex(k khulnasoft.StringInput) DogOutput {
	return khulnasoft.All(o, k).ApplyT(func(vs []interface{}) *Dog {
		return vs[0].(map[string]*Dog)[vs[1].(string)]
	}).(DogOutput)
}

func init() {
	khulnasoft.RegisterOutputType(DogOutput{})
	khulnasoft.RegisterOutputType(DogArrayOutput{})
	khulnasoft.RegisterOutputType(DogMapOutput{})
}
