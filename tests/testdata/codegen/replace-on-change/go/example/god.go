// Code generated by test DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package example

import (
	"context"
	"reflect"

	"github.com/khulnasoft/khulnasoft/sdk/v3/go/khulnasoft"
	"replace-on-change/example/internal"
)

type God struct {
	khulnasoft.CustomResourceState

	Backwards DogOutput `khulnasoft:"backwards"`
}

// NewGod registers a new resource with the given unique name, arguments, and options.
func NewGod(ctx *khulnasoft.Context,
	name string, args *GodArgs, opts ...khulnasoft.ResourceOption) (*God, error) {
	if args == nil {
		args = &GodArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource God
	err := ctx.RegisterResource("example::God", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGod gets an existing God resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGod(ctx *khulnasoft.Context,
	name string, id khulnasoft.IDInput, state *GodState, opts ...khulnasoft.ResourceOption) (*God, error) {
	var resource God
	err := ctx.ReadResource("example::God", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering God resources.
type godState struct {
}

type GodState struct {
}

func (GodState) ElementType() reflect.Type {
	return reflect.TypeOf((*godState)(nil)).Elem()
}

type godArgs struct {
}

// The set of arguments for constructing a God resource.
type GodArgs struct {
}

func (GodArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*godArgs)(nil)).Elem()
}

type GodInput interface {
	khulnasoft.Input

	ToGodOutput() GodOutput
	ToGodOutputWithContext(ctx context.Context) GodOutput
}

func (*God) ElementType() reflect.Type {
	return reflect.TypeOf((**God)(nil)).Elem()
}

func (i *God) ToGodOutput() GodOutput {
	return i.ToGodOutputWithContext(context.Background())
}

func (i *God) ToGodOutputWithContext(ctx context.Context) GodOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(GodOutput)
}

// GodArrayInput is an input type that accepts GodArray and GodArrayOutput values.
// You can construct a concrete instance of `GodArrayInput` via:
//
//	GodArray{ GodArgs{...} }
type GodArrayInput interface {
	khulnasoft.Input

	ToGodArrayOutput() GodArrayOutput
	ToGodArrayOutputWithContext(context.Context) GodArrayOutput
}

type GodArray []GodInput

func (GodArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*God)(nil)).Elem()
}

func (i GodArray) ToGodArrayOutput() GodArrayOutput {
	return i.ToGodArrayOutputWithContext(context.Background())
}

func (i GodArray) ToGodArrayOutputWithContext(ctx context.Context) GodArrayOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(GodArrayOutput)
}

// GodMapInput is an input type that accepts GodMap and GodMapOutput values.
// You can construct a concrete instance of `GodMapInput` via:
//
//	GodMap{ "key": GodArgs{...} }
type GodMapInput interface {
	khulnasoft.Input

	ToGodMapOutput() GodMapOutput
	ToGodMapOutputWithContext(context.Context) GodMapOutput
}

type GodMap map[string]GodInput

func (GodMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*God)(nil)).Elem()
}

func (i GodMap) ToGodMapOutput() GodMapOutput {
	return i.ToGodMapOutputWithContext(context.Background())
}

func (i GodMap) ToGodMapOutputWithContext(ctx context.Context) GodMapOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(GodMapOutput)
}

type GodOutput struct{ *khulnasoft.OutputState }

func (GodOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**God)(nil)).Elem()
}

func (o GodOutput) ToGodOutput() GodOutput {
	return o
}

func (o GodOutput) ToGodOutputWithContext(ctx context.Context) GodOutput {
	return o
}

func (o GodOutput) Backwards() DogOutput {
	return o.ApplyT(func(v *God) DogOutput { return v.Backwards }).(DogOutput)
}

type GodArrayOutput struct{ *khulnasoft.OutputState }

func (GodArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*God)(nil)).Elem()
}

func (o GodArrayOutput) ToGodArrayOutput() GodArrayOutput {
	return o
}

func (o GodArrayOutput) ToGodArrayOutputWithContext(ctx context.Context) GodArrayOutput {
	return o
}

func (o GodArrayOutput) Index(i khulnasoft.IntInput) GodOutput {
	return khulnasoft.All(o, i).ApplyT(func(vs []interface{}) *God {
		return vs[0].([]*God)[vs[1].(int)]
	}).(GodOutput)
}

type GodMapOutput struct{ *khulnasoft.OutputState }

func (GodMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*God)(nil)).Elem()
}

func (o GodMapOutput) ToGodMapOutput() GodMapOutput {
	return o
}

func (o GodMapOutput) ToGodMapOutputWithContext(ctx context.Context) GodMapOutput {
	return o
}

func (o GodMapOutput) MapIndex(k khulnasoft.StringInput) GodOutput {
	return khulnasoft.All(o, k).ApplyT(func(vs []interface{}) *God {
		return vs[0].(map[string]*God)[vs[1].(string)]
	}).(GodOutput)
}

func init() {
	khulnasoft.RegisterOutputType(GodOutput{})
	khulnasoft.RegisterOutputType(GodArrayOutput{})
	khulnasoft.RegisterOutputType(GodMapOutput{})
}
