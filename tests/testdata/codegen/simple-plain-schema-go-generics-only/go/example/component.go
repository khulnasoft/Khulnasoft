// Code generated by test DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package example

import (
	"context"
	"reflect"

	"errors"
	"github.com/khulnasoft/khulnasoft/sdk/v3/go/khulnasoft"
	"github.com/khulnasoft/khulnasoft/sdk/v3/go/khulnasoftx"
	"simple-plain-schema-go-generics-only/example/internal"
)

type Component struct {
	khulnasoft.ResourceState

	A   khulnasoftx.Output[bool]                 `khulnasoft:"a"`
	B   khulnasoftx.Output[*bool]                `khulnasoft:"b"`
	Bar khulnasoftx.GPtrOutput[Foo, FooOutput]   `khulnasoft:"bar"`
	Baz khulnasoftx.GArrayOutput[Foo, FooOutput] `khulnasoft:"baz"`
	C   khulnasoftx.Output[int]                  `khulnasoft:"c"`
	D   khulnasoftx.Output[*int]                 `khulnasoft:"d"`
	E   khulnasoftx.Output[string]               `khulnasoft:"e"`
	F   khulnasoftx.Output[*string]              `khulnasoft:"f"`
	Foo khulnasoftx.GPtrOutput[Foo, FooOutput]   `khulnasoft:"foo"`
}

// NewComponent registers a new resource with the given unique name, arguments, and options.
func NewComponent(ctx *khulnasoft.Context,
	name string, args *ComponentArgs, opts ...khulnasoft.ResourceOption) (*Component, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Component
	err := ctx.RegisterRemoteComponentResource("example::Component", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type componentArgs struct {
	A      bool           `khulnasoft:"a"`
	B      *bool          `khulnasoft:"b"`
	Bar    *Foo           `khulnasoft:"bar"`
	Baz    []Foo          `khulnasoft:"baz"`
	BazMap map[string]Foo `khulnasoft:"bazMap"`
	C      int            `khulnasoft:"c"`
	D      *int           `khulnasoft:"d"`
	E      string         `khulnasoft:"e"`
	F      *string        `khulnasoft:"f"`
	Foo    *Foo           `khulnasoft:"foo"`
}

// The set of arguments for constructing a Component resource.
type ComponentArgs struct {
	A      bool
	B      *bool
	Bar    *Foo
	Baz    []Foo
	BazMap map[string]Foo
	C      int
	D      *int
	E      string
	F      *string
	Foo    khulnasoftx.Input[*FooArgs]
}

func (ComponentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*componentArgs)(nil)).Elem()
}

type ComponentOutput struct{ *khulnasoft.OutputState }

func (ComponentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Component)(nil)).Elem()
}

func (o ComponentOutput) ToComponentOutput() ComponentOutput {
	return o
}

func (o ComponentOutput) ToComponentOutputWithContext(ctx context.Context) ComponentOutput {
	return o
}

func (o ComponentOutput) ToOutput(ctx context.Context) khulnasoftx.Output[Component] {
	return khulnasoftx.Output[Component]{
		OutputState: o.OutputState,
	}
}

func (o ComponentOutput) A() khulnasoftx.Output[bool] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.Output[bool] { return v.A })
	return khulnasoftx.Flatten[bool, khulnasoftx.Output[bool]](value)
}

func (o ComponentOutput) B() khulnasoftx.Output[*bool] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.Output[*bool] { return v.B })
	return khulnasoftx.Flatten[*bool, khulnasoftx.Output[*bool]](value)
}

func (o ComponentOutput) Bar() khulnasoftx.GPtrOutput[Foo, FooOutput] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.GPtrOutput[Foo, FooOutput] { return v.Bar })
	unwrapped := khulnasoftx.Flatten[*Foo, khulnasoftx.GPtrOutput[Foo, FooOutput]](value)
	return khulnasoftx.GPtrOutput[Foo, FooOutput]{OutputState: unwrapped.OutputState}
}

func (o ComponentOutput) Baz() khulnasoftx.GArrayOutput[Foo, FooOutput] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.GArrayOutput[Foo, FooOutput] { return v.Baz })
	unwrapped := khulnasoftx.Flatten[[]Foo, khulnasoftx.GArrayOutput[Foo, FooOutput]](value)
	return khulnasoftx.GArrayOutput[Foo, FooOutput]{OutputState: unwrapped.OutputState}
}

func (o ComponentOutput) C() khulnasoftx.Output[int] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.Output[int] { return v.C })
	return khulnasoftx.Flatten[int, khulnasoftx.Output[int]](value)
}

func (o ComponentOutput) D() khulnasoftx.Output[*int] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.Output[*int] { return v.D })
	return khulnasoftx.Flatten[*int, khulnasoftx.Output[*int]](value)
}

func (o ComponentOutput) E() khulnasoftx.Output[string] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.Output[string] { return v.E })
	return khulnasoftx.Flatten[string, khulnasoftx.Output[string]](value)
}

func (o ComponentOutput) F() khulnasoftx.Output[*string] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.Output[*string] { return v.F })
	return khulnasoftx.Flatten[*string, khulnasoftx.Output[*string]](value)
}

func (o ComponentOutput) Foo() khulnasoftx.GPtrOutput[Foo, FooOutput] {
	value := khulnasoftx.Apply[Component](o, func(v Component) khulnasoftx.GPtrOutput[Foo, FooOutput] { return v.Foo })
	unwrapped := khulnasoftx.Flatten[*Foo, khulnasoftx.GPtrOutput[Foo, FooOutput]](value)
	return khulnasoftx.GPtrOutput[Foo, FooOutput]{OutputState: unwrapped.OutputState}
}

func init() {
	khulnasoft.RegisterOutputType(ComponentOutput{})
}
