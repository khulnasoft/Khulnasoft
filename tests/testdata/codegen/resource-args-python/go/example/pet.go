// Code generated by test DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package example

import (
	"context"
	"reflect"

	"github.com/khulnasoft/khulnasoft/sdk/v3/go/khulnasoft"
	"resource-args-python/example/internal"
)

type Pet struct {
	khulnasoft.CustomResourceState

	Name khulnasoft.StringPtrOutput `khulnasoft:"name"`
}

// NewPet registers a new resource with the given unique name, arguments, and options.
func NewPet(ctx *khulnasoft.Context,
	name string, args *PetArgs, opts ...khulnasoft.ResourceOption) (*Pet, error) {
	if args == nil {
		args = &PetArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Pet
	err := ctx.RegisterResource("example::Pet", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPet gets an existing Pet resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPet(ctx *khulnasoft.Context,
	name string, id khulnasoft.IDInput, state *PetState, opts ...khulnasoft.ResourceOption) (*Pet, error) {
	var resource Pet
	err := ctx.ReadResource("example::Pet", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Pet resources.
type petState struct {
}

type PetState struct {
}

func (PetState) ElementType() reflect.Type {
	return reflect.TypeOf((*petState)(nil)).Elem()
}

type petArgs struct {
	Name *string `khulnasoft:"name"`
}

// The set of arguments for constructing a Pet resource.
type PetArgs struct {
	Name khulnasoft.StringPtrInput
}

func (PetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*petArgs)(nil)).Elem()
}

type PetInput interface {
	khulnasoft.Input

	ToPetOutput() PetOutput
	ToPetOutputWithContext(ctx context.Context) PetOutput
}

func (*Pet) ElementType() reflect.Type {
	return reflect.TypeOf((**Pet)(nil)).Elem()
}

func (i *Pet) ToPetOutput() PetOutput {
	return i.ToPetOutputWithContext(context.Background())
}

func (i *Pet) ToPetOutputWithContext(ctx context.Context) PetOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(PetOutput)
}

// PetArrayInput is an input type that accepts PetArray and PetArrayOutput values.
// You can construct a concrete instance of `PetArrayInput` via:
//
//	PetArray{ PetArgs{...} }
type PetArrayInput interface {
	khulnasoft.Input

	ToPetArrayOutput() PetArrayOutput
	ToPetArrayOutputWithContext(context.Context) PetArrayOutput
}

type PetArray []PetInput

func (PetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Pet)(nil)).Elem()
}

func (i PetArray) ToPetArrayOutput() PetArrayOutput {
	return i.ToPetArrayOutputWithContext(context.Background())
}

func (i PetArray) ToPetArrayOutputWithContext(ctx context.Context) PetArrayOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(PetArrayOutput)
}

// PetMapInput is an input type that accepts PetMap and PetMapOutput values.
// You can construct a concrete instance of `PetMapInput` via:
//
//	PetMap{ "key": PetArgs{...} }
type PetMapInput interface {
	khulnasoft.Input

	ToPetMapOutput() PetMapOutput
	ToPetMapOutputWithContext(context.Context) PetMapOutput
}

type PetMap map[string]PetInput

func (PetMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Pet)(nil)).Elem()
}

func (i PetMap) ToPetMapOutput() PetMapOutput {
	return i.ToPetMapOutputWithContext(context.Background())
}

func (i PetMap) ToPetMapOutputWithContext(ctx context.Context) PetMapOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(PetMapOutput)
}

type PetOutput struct{ *khulnasoft.OutputState }

func (PetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Pet)(nil)).Elem()
}

func (o PetOutput) ToPetOutput() PetOutput {
	return o
}

func (o PetOutput) ToPetOutputWithContext(ctx context.Context) PetOutput {
	return o
}

func (o PetOutput) Name() khulnasoft.StringPtrOutput {
	return o.ApplyT(func(v *Pet) khulnasoft.StringPtrOutput { return v.Name }).(khulnasoft.StringPtrOutput)
}

type PetArrayOutput struct{ *khulnasoft.OutputState }

func (PetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Pet)(nil)).Elem()
}

func (o PetArrayOutput) ToPetArrayOutput() PetArrayOutput {
	return o
}

func (o PetArrayOutput) ToPetArrayOutputWithContext(ctx context.Context) PetArrayOutput {
	return o
}

func (o PetArrayOutput) Index(i khulnasoft.IntInput) PetOutput {
	return khulnasoft.All(o, i).ApplyT(func(vs []interface{}) *Pet {
		return vs[0].([]*Pet)[vs[1].(int)]
	}).(PetOutput)
}

type PetMapOutput struct{ *khulnasoft.OutputState }

func (PetMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Pet)(nil)).Elem()
}

func (o PetMapOutput) ToPetMapOutput() PetMapOutput {
	return o
}

func (o PetMapOutput) ToPetMapOutputWithContext(ctx context.Context) PetMapOutput {
	return o
}

func (o PetMapOutput) MapIndex(k khulnasoft.StringInput) PetOutput {
	return khulnasoft.All(o, k).ApplyT(func(vs []interface{}) *Pet {
		return vs[0].(map[string]*Pet)[vs[1].(string)]
	}).(PetOutput)
}

func init() {
	khulnasoft.RegisterInputType(reflect.TypeOf((*PetInput)(nil)).Elem(), &Pet{})
	khulnasoft.RegisterInputType(reflect.TypeOf((*PetArrayInput)(nil)).Elem(), PetArray{})
	khulnasoft.RegisterInputType(reflect.TypeOf((*PetMapInput)(nil)).Elem(), PetMap{})
	khulnasoft.RegisterOutputType(PetOutput{})
	khulnasoft.RegisterOutputType(PetArrayOutput{})
	khulnasoft.RegisterOutputType(PetMapOutput{})
}
