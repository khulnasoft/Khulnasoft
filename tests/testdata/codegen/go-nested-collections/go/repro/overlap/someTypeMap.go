// Code generated by test DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package overlap

import (
	"context"
	"reflect"

	"github.com/khulnasoft/khulnasoft/sdk/v3/go/khulnasoft"
	"go-nested-collections/repro/internal"
)

type SomeTypeMapResource struct {
	khulnasoft.CustomResourceState
}

// NewSomeTypeMapResource registers a new resource with the given unique name, arguments, and options.
func NewSomeTypeMapResource(ctx *khulnasoft.Context,
	name string, args *SomeTypeMapResourceArgs, opts ...khulnasoft.ResourceOption) (*SomeTypeMapResource, error) {
	if args == nil {
		args = &SomeTypeMapResourceArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SomeTypeMapResource
	err := ctx.RegisterResource("repro:overlap:SomeTypeMap", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSomeTypeMapResource gets an existing SomeTypeMapResource resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSomeTypeMapResource(ctx *khulnasoft.Context,
	name string, id khulnasoft.IDInput, state *SomeTypeMapResourceState, opts ...khulnasoft.ResourceOption) (*SomeTypeMapResource, error) {
	var resource SomeTypeMapResource
	err := ctx.ReadResource("repro:overlap:SomeTypeMap", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SomeTypeMapResource resources.
type someTypeMapResourceState struct {
}

type SomeTypeMapResourceState struct {
}

func (SomeTypeMapResourceState) ElementType() reflect.Type {
	return reflect.TypeOf((*someTypeMapResourceState)(nil)).Elem()
}

type someTypeMapResourceArgs struct {
}

// The set of arguments for constructing a SomeTypeMapResource resource.
type SomeTypeMapResourceArgs struct {
}

func (SomeTypeMapResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*someTypeMapResourceArgs)(nil)).Elem()
}

type SomeTypeMapResourceInput interface {
	khulnasoft.Input

	ToSomeTypeMapResourceOutput() SomeTypeMapResourceOutput
	ToSomeTypeMapResourceOutputWithContext(ctx context.Context) SomeTypeMapResourceOutput
}

func (*SomeTypeMapResource) ElementType() reflect.Type {
	return reflect.TypeOf((**SomeTypeMapResource)(nil)).Elem()
}

func (i *SomeTypeMapResource) ToSomeTypeMapResourceOutput() SomeTypeMapResourceOutput {
	return i.ToSomeTypeMapResourceOutputWithContext(context.Background())
}

func (i *SomeTypeMapResource) ToSomeTypeMapResourceOutputWithContext(ctx context.Context) SomeTypeMapResourceOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(SomeTypeMapResourceOutput)
}

// SomeTypeMapResourceArrayInput is an input type that accepts SomeTypeMapResourceArray and SomeTypeMapResourceArrayOutput values.
// You can construct a concrete instance of `SomeTypeMapResourceArrayInput` via:
//
//	SomeTypeMapResourceArray{ SomeTypeMapResourceArgs{...} }
type SomeTypeMapResourceArrayInput interface {
	khulnasoft.Input

	ToSomeTypeMapResourceArrayOutput() SomeTypeMapResourceArrayOutput
	ToSomeTypeMapResourceArrayOutputWithContext(context.Context) SomeTypeMapResourceArrayOutput
}

type SomeTypeMapResourceArray []SomeTypeMapResourceInput

func (SomeTypeMapResourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SomeTypeMapResource)(nil)).Elem()
}

func (i SomeTypeMapResourceArray) ToSomeTypeMapResourceArrayOutput() SomeTypeMapResourceArrayOutput {
	return i.ToSomeTypeMapResourceArrayOutputWithContext(context.Background())
}

func (i SomeTypeMapResourceArray) ToSomeTypeMapResourceArrayOutputWithContext(ctx context.Context) SomeTypeMapResourceArrayOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(SomeTypeMapResourceArrayOutput)
}

// SomeTypeMapResourceMapInput is an input type that accepts SomeTypeMapResourceMap and SomeTypeMapResourceMapOutput values.
// You can construct a concrete instance of `SomeTypeMapResourceMapInput` via:
//
//	SomeTypeMapResourceMap{ "key": SomeTypeMapResourceArgs{...} }
type SomeTypeMapResourceMapInput interface {
	khulnasoft.Input

	ToSomeTypeMapResourceMapOutput() SomeTypeMapResourceMapOutput
	ToSomeTypeMapResourceMapOutputWithContext(context.Context) SomeTypeMapResourceMapOutput
}

type SomeTypeMapResourceMap map[string]SomeTypeMapResourceInput

func (SomeTypeMapResourceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SomeTypeMapResource)(nil)).Elem()
}

func (i SomeTypeMapResourceMap) ToSomeTypeMapResourceMapOutput() SomeTypeMapResourceMapOutput {
	return i.ToSomeTypeMapResourceMapOutputWithContext(context.Background())
}

func (i SomeTypeMapResourceMap) ToSomeTypeMapResourceMapOutputWithContext(ctx context.Context) SomeTypeMapResourceMapOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(SomeTypeMapResourceMapOutput)
}

type SomeTypeMapResourceOutput struct{ *khulnasoft.OutputState }

func (SomeTypeMapResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SomeTypeMapResource)(nil)).Elem()
}

func (o SomeTypeMapResourceOutput) ToSomeTypeMapResourceOutput() SomeTypeMapResourceOutput {
	return o
}

func (o SomeTypeMapResourceOutput) ToSomeTypeMapResourceOutputWithContext(ctx context.Context) SomeTypeMapResourceOutput {
	return o
}

type SomeTypeMapResourceArrayOutput struct{ *khulnasoft.OutputState }

func (SomeTypeMapResourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SomeTypeMapResource)(nil)).Elem()
}

func (o SomeTypeMapResourceArrayOutput) ToSomeTypeMapResourceArrayOutput() SomeTypeMapResourceArrayOutput {
	return o
}

func (o SomeTypeMapResourceArrayOutput) ToSomeTypeMapResourceArrayOutputWithContext(ctx context.Context) SomeTypeMapResourceArrayOutput {
	return o
}

func (o SomeTypeMapResourceArrayOutput) Index(i khulnasoft.IntInput) SomeTypeMapResourceOutput {
	return khulnasoft.All(o, i).ApplyT(func(vs []interface{}) *SomeTypeMapResource {
		return vs[0].([]*SomeTypeMapResource)[vs[1].(int)]
	}).(SomeTypeMapResourceOutput)
}

type SomeTypeMapResourceMapOutput struct{ *khulnasoft.OutputState }

func (SomeTypeMapResourceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SomeTypeMapResource)(nil)).Elem()
}

func (o SomeTypeMapResourceMapOutput) ToSomeTypeMapResourceMapOutput() SomeTypeMapResourceMapOutput {
	return o
}

func (o SomeTypeMapResourceMapOutput) ToSomeTypeMapResourceMapOutputWithContext(ctx context.Context) SomeTypeMapResourceMapOutput {
	return o
}

func (o SomeTypeMapResourceMapOutput) MapIndex(k khulnasoft.StringInput) SomeTypeMapResourceOutput {
	return khulnasoft.All(o, k).ApplyT(func(vs []interface{}) *SomeTypeMapResource {
		return vs[0].(map[string]*SomeTypeMapResource)[vs[1].(string)]
	}).(SomeTypeMapResourceOutput)
}

func init() {
	khulnasoft.RegisterInputType(reflect.TypeOf((*SomeTypeMapResourceInput)(nil)).Elem(), &SomeTypeMapResource{})
	khulnasoft.RegisterInputType(reflect.TypeOf((*SomeTypeMapResourceArrayInput)(nil)).Elem(), SomeTypeMapResourceArray{})
	khulnasoft.RegisterInputType(reflect.TypeOf((*SomeTypeMapResourceMapInput)(nil)).Elem(), SomeTypeMapResourceMap{})
	khulnasoft.RegisterOutputType(SomeTypeMapResourceOutput{})
	khulnasoft.RegisterOutputType(SomeTypeMapResourceArrayOutput{})
	khulnasoft.RegisterOutputType(SomeTypeMapResourceMapOutput{})
}
