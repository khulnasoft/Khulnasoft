// Code generated by test DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package world

import (
	"context"
	"reflect"

	"github.com/khulnasoft/khulnasoft/sdk/v3/go/khulnasoft"
	"regress-go-10527/world/internal"
)

type Universe struct {
	khulnasoft.CustomResourceState
}

// NewUniverse registers a new resource with the given unique name, arguments, and options.
func NewUniverse(ctx *khulnasoft.Context,
	name string, args *UniverseArgs, opts ...khulnasoft.ResourceOption) (*Universe, error) {
	if args == nil {
		args = &UniverseArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Universe
	err := ctx.RegisterResource("world::Universe", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUniverse gets an existing Universe resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUniverse(ctx *khulnasoft.Context,
	name string, id khulnasoft.IDInput, state *UniverseState, opts ...khulnasoft.ResourceOption) (*Universe, error) {
	var resource Universe
	err := ctx.ReadResource("world::Universe", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Universe resources.
type universeState struct {
}

type UniverseState struct {
}

func (UniverseState) ElementType() reflect.Type {
	return reflect.TypeOf((*universeState)(nil)).Elem()
}

type universeArgs struct {
	Worlds map[string]World `khulnasoft:"worlds"`
}

// The set of arguments for constructing a Universe resource.
type UniverseArgs struct {
	Worlds WorldMapInput
}

func (UniverseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*universeArgs)(nil)).Elem()
}

type UniverseInput interface {
	khulnasoft.Input

	ToUniverseOutput() UniverseOutput
	ToUniverseOutputWithContext(ctx context.Context) UniverseOutput
}

func (*Universe) ElementType() reflect.Type {
	return reflect.TypeOf((**Universe)(nil)).Elem()
}

func (i *Universe) ToUniverseOutput() UniverseOutput {
	return i.ToUniverseOutputWithContext(context.Background())
}

func (i *Universe) ToUniverseOutputWithContext(ctx context.Context) UniverseOutput {
	return khulnasoft.ToOutputWithContext(ctx, i).(UniverseOutput)
}

type UniverseOutput struct{ *khulnasoft.OutputState }

func (UniverseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Universe)(nil)).Elem()
}

func (o UniverseOutput) ToUniverseOutput() UniverseOutput {
	return o
}

func (o UniverseOutput) ToUniverseOutputWithContext(ctx context.Context) UniverseOutput {
	return o
}

func init() {
	khulnasoft.RegisterInputType(reflect.TypeOf((*UniverseInput)(nil)).Elem(), &Universe{})
	khulnasoft.RegisterOutputType(UniverseOutput{})
}
